package com.dianping.zebra.group.router;import java.beans.PropertyChangeEvent;import java.beans.PropertyChangeListener;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Set;import com.dianping.zebra.group.SqlType;import com.dianping.zebra.group.config.DataSourceConfigManager;import com.dianping.zebra.group.config.datasource.entity.DataSourceConfig;import com.dianping.zebra.group.util.SqlUtils;/** * 读写分离的DataSource选择器 */public class GroupReadWriteDataSourceRouter implements GroupDataSourceRouter, PropertyChangeListener {	private GroupWeightDataSourceRouter readRouter;	private GroupWeightDataSourceRouter writeRouter;	private DataSourceConfigManager configManager;	public GroupReadWriteDataSourceRouter(DataSourceConfigManager configManager) {		this.configManager = configManager;		this.init(configManager.getAvailableDataSources());	}	private void init(Map<String, DataSourceConfig> dataSourceConfigs) {		List<DataSourceConfig> readDataSourceConfigs = new ArrayList<DataSourceConfig>();		List<DataSourceConfig> writeDataSourceConfigs = new ArrayList<DataSourceConfig>();		for (DataSourceConfig config : dataSourceConfigs.values()) {			if (config.isReadonly()) {				readDataSourceConfigs.add(config);			} else {				writeDataSourceConfigs.add(config);			}		}		this.readRouter = new GroupWeightDataSourceRouter(readDataSourceConfigs, true);		this.writeRouter = new GroupWeightDataSourceRouter(writeDataSourceConfigs, false);	}	@Override	public GroupDataSourceTarget select(GroupDataSourceRouterInfo routerInfo) {		return this.select(routerInfo, null);	}	@Override	public GroupDataSourceTarget select(GroupDataSourceRouterInfo routerInfo, Set<GroupDataSourceTarget> excludeTargets) {		GroupDataSourceContext dsContext = GroupDataSourceContext.get();		if (dsContext.getMasterFlag()) {			return writeRouter.select(routerInfo, excludeTargets);		} else {			// 判断出sql的SqlType，算出它是read还是write			SqlType sqlType = getSqlType(routerInfo);			if (sqlType.isRead()) {				return readRouter.select(routerInfo, excludeTargets);			} else {				return writeRouter.select(routerInfo, excludeTargets);			}		}	}	private SqlType getSqlType(GroupDataSourceRouterInfo routerInfo) {		String sql = routerInfo.getSql();		try {			return SqlUtils.getSqlType(sql);		} catch (SQLException e) {			throw new RuntimeException(e.getMessage(), e);		}	}	public String getName() {		return this.getName();	}	@Override	public String getRouterStrategy() {		return "roundrobin";	}	@Override	public void propertyChange(PropertyChangeEvent evt) {		this.init(configManager.getAvailableDataSources());	}}