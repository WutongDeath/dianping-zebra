package com.dianping.zebra.group.router;import java.beans.PropertyChangeEvent;import java.beans.PropertyChangeListener;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.ServiceLoader;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import org.apache.commons.lang.StringUtils;import org.apache.commons.lang.builder.ReflectionToStringBuilder;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.dianping.zebra.group.Constants;import com.dianping.zebra.group.SqlType;import com.dianping.zebra.group.config.DataSourceConfigManager;import com.dianping.zebra.group.config.datasource.entity.DataSourceConfig;import com.dianping.zebra.group.datasources.GroupDataSourceManager;import com.dianping.zebra.group.util.SqlUtils;/** * 读写分离的DataSource选择器 */public class GroupReadWriteDataSourceRouter implements GroupDataSourceRouter, PropertyChangeListener {	private static final Logger logger = LoggerFactory.getLogger(GroupReadWriteDataSourceRouter.class);	private String biz;	private GroupWeightDataSourceRouter readrouter;	private GroupWeightDataSourceRouter writerouter;	private Map<String, DataSourceConfig> dataSourceConfigs = new ConcurrentHashMap<String, DataSourceConfig>();	private DataSourceConfigManager dataSourceConfigManager;	private GroupDataSourceManager groupDataSourcePool;	private CustomizedReadWriteStrategy customizedReadWriteStrategy;	public GroupReadWriteDataSourceRouter(DataSourceConfigManager dataSourceConfigManager,	      GroupDataSourceManager groupDataSourcePool) {		this.dataSourceConfigManager = dataSourceConfigManager;		this.groupDataSourcePool = groupDataSourcePool;		this.biz = dataSourceConfigManager.getBiz();		this.initDataSource(dataSourceConfigManager.getAvailableDataSources());		this.initRouter(dataSourceConfigManager.getAvailableDataSources());		loadCustomizedReadWriteStrategy();	}	private void initDataSource(Map<String, DataSourceConfig> dataSourceConfigs) {		for (DataSourceConfig config : dataSourceConfigs.values()) {			groupDataSourcePool.createDataSource(this.biz, config);		}	}	private void initRouter(Map<String, DataSourceConfig> dataSourceConfigs) {		List<DataSourceConfig> readDataSourceConfigs = new ArrayList<DataSourceConfig>();		List<DataSourceConfig> writeDataSourceConfigs = new ArrayList<DataSourceConfig>();		for (DataSourceConfig config : dataSourceConfigs.values()) {			if (config.getCanRead()) {				readDataSourceConfigs.add(config);			}			if (config.getCanWrite()) {				writeDataSourceConfigs.add(config);			}		}		this.readrouter = new GroupWeightDataSourceRouter(readDataSourceConfigs, groupDataSourcePool);		this.writerouter = new GroupWeightDataSourceRouter(writeDataSourceConfigs, groupDataSourcePool);		this.dataSourceConfigs = dataSourceConfigs;	}	private void loadCustomizedReadWriteStrategy() {		ServiceLoader<CustomizedReadWriteStrategy> strategies = ServiceLoader.load(CustomizedReadWriteStrategy.class);		if (strategies != null) {			for (CustomizedReadWriteStrategy strategy : strategies) {				if (strategy != null) {					customizedReadWriteStrategy = strategy;					break;				}			}		}	}	@Override	public GroupDataSourceTarget select(GroupDataSourceRouterInfo routerInfo) {		return this.select(routerInfo, null);	}	@Override	public GroupDataSourceTarget select(GroupDataSourceRouterInfo routerInfo, Set<GroupDataSourceTarget> excludeTargets) {		if (routerInfo.isForceWrite()		      || StringUtils.trimToEmpty(routerInfo.getSql()).startsWith(Constants.SQL_FORCE_WRITE_HINT)		      || (customizedReadWriteStrategy != null && customizedReadWriteStrategy.forceReadFromMaster())) {			return writerouter.select(routerInfo, excludeTargets);		} else {			// 判断出sql的SqlType，算出它是read还是write			SqlType sqlType = getSqlType(routerInfo);			if (sqlType.isRead()) {				return readrouter.select(routerInfo, excludeTargets);			} else {				return writerouter.select(routerInfo, excludeTargets);			}		}	}	private SqlType getSqlType(GroupDataSourceRouterInfo routerInfo) {		String sql = routerInfo.getSql();		try {			return SqlUtils.getSqlType(sql);		} catch (SQLException e) {			throw new RuntimeException(e.getMessage(), e);		}	}	@Override	public String getName() {		return "roundrobin";	}	@Override	public void propertyChange(PropertyChangeEvent evt) {		List<String> toBeDestoryDataSource = new ArrayList<String>();		Map<String, DataSourceConfig> newConfig = dataSourceConfigManager.getAvailableDataSources();		logger.info(String.format("New dataSource config changed from %s to %s",		      printDataSourceConfig(dataSourceConfigs), printDataSourceConfig(newConfig)));		try {			for (Entry<String, DataSourceConfig> entry : dataSourceConfigs.entrySet()) {				String key = entry.getKey();				if (!newConfig.containsKey(key)) {					toBeDestoryDataSource.add(key);				}			}			logger.info(String.format("To destroy following dataSources: %s", toBeDestoryDataSource));			this.initDataSource(newConfig);			this.initRouter(newConfig);			for (String dsId : toBeDestoryDataSource) {				groupDataSourcePool.destory(dsId, this.biz);			}		} catch (Throwable e) {			logger.warn("cannot refresh dataSource!", e);		}	}	private String printDataSourceConfig(Map<String, DataSourceConfig> config) {		StringBuilder sb = new StringBuilder("{");		boolean isFirst = true;		for (Entry<String, DataSourceConfig> entry : config.entrySet()) {			if (isFirst) {				isFirst = false;			} else {				sb.append(",");			}			sb.append(entry.getKey());			sb.append("=");			sb.append(ReflectionToStringBuilder.toString(entry.getValue()));		}		sb.append("}");		return sb.toString();	}}